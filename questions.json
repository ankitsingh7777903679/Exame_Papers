{
  "iot": {
    "mcq": [
      {
        "question": "1. What does IoT stand for?",
        "options": ["a) Internet of Things", "b) Internet of Technology"],
        "correctAnswer": "a",
        "id": "iot-q1"
      }
    ],
    "onemarks": [
      {
        "question": "1. What is IoT?",
        "answer": "Internet of Things (IoT) is a network of physical objects or people called 'things' that are embedded with software, electronics, network, and sensors that allow these objects to collect and exchange data."
      }
    ],
    "long": [
      {
        "question": "1. Explain the architecture of IoT.",
        "answer": "The IoT architecture consists of several layers:\n- **Perception Layer**: Includes sensors and devices that collect data.\n- **Network Layer**: Facilitates communication between devices using protocols like Wi-Fi, Bluetooth, etc.\n- **Application Layer**: Provides user interfaces and services, such as smart home apps or healthcare monitoring systems.\nEach layer works together to enable seamless data flow and automation."
      }
    ]
  },
  "java": {
    "mcq": [
      {
        "question": "1. What does JVM stand for?",
        "options": ["a) Java Virtual Machine", "b) Java Variable Machine"],
        "correctAnswer": "a",
        "id": "java-q1"
      }
    ],
    "onemarks": [
      {
        "question": "1. What is JVM?",
        "answer": "The Java Virtual Machine (JVM) is an abstract computing machine that enables a computer to run a Java program."
      },
      {
        "question": "2. What is the unsigned right shift operator in Java?",
        "answer": "The unsigned right shift, also known as the zero-fill right shift, is a bit manipulation operation in Java. It shifts the bits of a number to the right, and instead of preserving the sign bit (like the signed right shift), it fills the leftmost bits with zeros. This is represented by the operator >>> in Java.",
        "code": "int number = -8; // Binary: 11111111111111111111111111111000\nint result = number >>> 2; // Shifts"
      },
      {
        "question": "3. Give Use of this keyword.",
        "answer": "In Java, the this keyword is a reference to the current object in a method or constructor.",
        "code": "public void setName(String name) {\n    this.name = name; // Refers to the instance variable 'name'\n}\n\npublic Person(String name) {\n    this(name, 25); // Calls the constructor with two parameters\n}\n\npublic Person(String name, int age) {\n    this.name = name;\n    this.age = age;\n}"
      },
      {
        "question": "4. What is the difference between checked and unchecked exceptions?",
        "answer": "Checked exceptions are checked at compile time, requiring the programmer to handle them using try-catch blocks or by declaring them in the method signature using throws. Examples include IOException and SQLException.\n Unchecked exceptions occur at runtime and are not checked during compilation. They typically represent programming errors, such as NullPointerException and ArrayIndexOutOfBoundsException.",
        "code": ""
      },
      {
        "question": "5. What is garbage collection?",
        "answer": "Garbage collection in Java is the process of automatically identifying and removing objects that are no longer in use to reclaim memory and prevent memory leaks. This ensures efficient memory management without requiring explicit deallocation by the programmer.",
        "code": ""
      },
      {
        "question": "6. List methods of the Graphics class.",
        "answer": "The Graphics class in Java provides methods for drawing shapes, text, and images. Common methods include drawLine(), drawRect(), drawOval(), drawString(), setColor(), and fillRect(). These methods are used in graphical programming for creating custom drawings.",
        "code": ""
      }
    ],
    "long": [
      {
        "question": "1. What are the features of Java?",
        "answer": "Java is a powerful, versatile programming language that is widely used in software development. Its features are what make it stand out as an efficient and robust language. Here are the detailed features:\n\n1. **Platform Independence:** Java's 'Write Once, Run Anywhere' principle allows code compiled on one platform to run seamlessly on another, thanks to the Java Virtual Machine (JVM).\n\n2. **Object-Oriented:** Java adopts the object-oriented programming paradigm, encouraging modular and reusable code by organizing it into classes and objects.\n\n3. **Robust:** With features like garbage collection, exception handling, and memory allocation, Java minimizes programming errors and ensures a stable runtime environment.\n\n4. **Secure:** Java applications are run in a secure environment. The security manager defines access rules for classes, providing protection against unauthorized access.\n\n5. **Multithreaded:** Java supports multithreading, enabling the simultaneous execution of two or more threads for maximum utilization of the CPU.\n\n6. **High Performance:** Java achieves high performance through the Just-In-Time (JIT) compiler, which translates bytecode into native machine code at runtime.\n\n7. **Dynamic and Extensible:** Java supports dynamic linking of classes at runtime and allows integration with libraries, making applications adaptable and flexible.\n\n8. **Rich API:** Java provides a wide array of built-in libraries for tasks like data structures, networking, GUI development, and more.\n\nHere’s a program that demonstrates some of these features, such as platform independence, object-oriented programming, and multithreading:\n\n",
        "code": "public class JavaFeaturesDemo implements Runnable {\n    private String message;\n\n    public JavaFeaturesDemo(String message) {\n        this.message = message; // Object-Oriented: Encapsulation\n    }\n\n    @Override\n    public void run() {\n        System.out.println(message);\n    }\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new JavaFeaturesDemo(\"Hello from Thread 1!\"));\n        Thread thread2 = new Thread(new JavaFeaturesDemo(\"Hello from Thread 2!\"));\n\n        thread1.start(); // Multithreading: Starts Thread 1\n        thread2.start(); // Multithreading: Starts Thread 2\n\n        System.out.println(\"Java is platform-independent, robust, and dynamic!\");\n    }\n}"
      },
      {
        "question": "2. Explain Java programming structure.",
        "answer": "A Java program follows a specific structure that ensures the program is organized, readable, and executable. The structure consists of the following components:\n\n1. **Package Declaration (Optional):** If the program belongs to a specific package, it begins with a package declaration.\n   Example: `package myPackage;`\n\n2. **Import Statements (Optional):** To include libraries or classes from Java's API, the `import` keyword is used.\n   Example: `import java.util.Scanner;`\n\n3. **Class Definition:** Every Java program is written inside a class. The class name must match the filename (if it is public).\n   Example: `public class MyProgram { ... }`\n\n4. **Main Method:** The `main` method serves as the entry point for program execution. Its signature is `public static void main(String[] args) { ... }`.\n\n5. **Variables and Methods:** Inside the class, you define variables and methods to perform specific tasks.\n   Example: `int num = 10;`\n\n6. **Comments:** Comments are added for clarity and do not affect program execution. They can be single-line (`//`) or multi-line (`/* */`).\n\nHere’s an example program that demonstrates the Java programming structure:",
        "code": "package myPackage;\n\nimport java.util.Scanner;\n\npublic class MyProgram {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Enter your name: \");\n        String name = scanner.nextLine(); // Reads user input\n        System.out.println(\"Hello, \" + name + \"!\"); // Prints output\n        scanner.close();\n    }\n}"
      },
      {
        "question": "3. Explain the static keyword in detail with its types.",
        "answer": "In Java, the static keyword is used to create variables, methods, blocks, or nested classes that are shared across all instances of the class. Static members belong to the class rather than any specific instance, making them memory efficient and easily accessible without creating an object.\n\n### Types of Static Members:\n\n1. **Static Variables:**\n   - Also known as class variables.\n   - These are shared across all objects of the class and only a single copy of the variable is maintained.\n   - Example: `static int count;`\n\n2. **Static Methods:**\n   - These are methods that can be called without creating an object of the class.\n   - Static methods cannot access instance variables or methods directly; they can only access other static members.\n   - Example: `static void display();`\n\n3. **Static Blocks:**\n   - A static block is used for initializing static variables.\n   - It is executed only once, when the class is loaded.\n   - Example:\n     ```java\n     static {\n         System.out.println(\"Static block executed!\");\n     }\n     ```\n\n4. **Static Nested Classes:**\n   - A static nested class is a class defined inside another class with the static modifier.\n   - It can be instantiated without an object of the outer class.\n   - Example:\n     ```java\n     static class NestedClass {\n         void display() {\n             System.out.println(\"Inside static nested class\");\n         }\n     }\n     ```",
        "code": "public class StaticKeywordDemo {\n    // Static variable\n    static int count = 0;\n\n    // Static method\n    static void displayCount() {\n        System.out.println(\"Count: \" + count);\n    }\n\n    // Static block\n    static {\n        count = 10;\n        System.out.println(\"Static block executed! Count initialized to \" + count);\n    }\n\n    // Static nested class\n    static class NestedClass {\n        void showMessage() {\n            System.out.println(\"Hello from the static nested class!\");\n        }\n    }\n\n    public static void main(String[] args) {\n        // Accessing static variable and method\n        StaticKeywordDemo.displayCount(); // Outputs: Count: 10\n\n        // Instantiating the static nested class\n        StaticKeywordDemo.NestedClass nested = new StaticKeywordDemo.NestedClass();\n        nested.showMessage(); // Outputs: Hello from the static nested class!\n    }\n}"
      },
      {
        "question": "4. Explain runtime polymorphism using an interface.",
        "answer": "Runtime polymorphism in Java occurs when a call to an overridden method is resolved at runtime rather than compile time. It is achieved by method overriding, typically through inheritance or interfaces. When a class implements an interface and provides implementations for its methods, the actual method that gets executed depends on the runtime type of the object being referred to, not the type of the reference variable. This enables dynamic method dispatch.\n\nInterfaces are used to achieve runtime polymorphism by defining a common method signature that different classes can implement differently. The appropriate implementation is determined at runtime based on the actual object being used.",
        "code": "interface Animal {\n    void sound(); // Interface method\n}\n\nclass Dog implements Animal {\n    @Override\n    public void sound() {\n        System.out.println(\"Woof\");\n    }\n}\n\nclass Cat implements Animal {\n    @Override\n    public void sound() {\n        System.out.println(\"Meow\");\n    }\n}\n\npublic class RuntimePolymorphismDemo {\n    public static void main(String[] args) {\n        Animal myAnimal;\n\n        myAnimal = new Dog(); // Runtime decision\n        myAnimal.sound(); // Outputs: Woof\n\n        myAnimal = new Cat(); // Runtime decision\n        myAnimal.sound(); // Outputs: Meow\n    }\n}"
      },
      {
        "question": "5. Give the difference between String and StringBuffer, and explain any 4 methods of the String class.",
        "answer": "**Difference between String and StringBuffer:**\n\n1. **Mutability:**\n   - String: Immutable. Any modification creates a new object.\n   - StringBuffer: Mutable. Modifications occur within the same object.\n\n2. **Performance:**\n   - String: Slower for frequent modifications due to object creation.\n   - StringBuffer: Faster for frequent modifications as it doesn’t create new objects.\n\n3. **Thread-Safety:**\n   - String: Not thread-safe.\n   - StringBuffer: Thread-safe because its methods are synchronized.\n\n4. **Usage:**\n   - String: Used when data doesn’t change frequently.\n   - StringBuffer: Used when data changes frequently (e.g., in loops).\n\n**4 Methods of the String Class:**\n\n1. **length():** Returns the length of the string.\n   ```java\n   String str = \"Hello\";\n   int len = str.length(); // Output: 5\n   ```\n\n2. **charAt(int index):** Returns the character at the specified index.\n   ```java\n   String str = \"Hello\";\n   char ch = str.charAt(1); // Output: 'e'\n   ```\n\n3. **substring(int beginIndex, int endIndex):** Returns a substring from the specified range.\n   ```java\n   String str = \"Hello World\";\n   String sub = str.substring(0, 5); // Output: \"Hello\"\n   ```\n\n4. **toUpperCase():** Converts all characters of the string to uppercase.\n   ```java\n   String str = \"hello\";\n   String upper = str.toUpperCase(); // Output: \"HELLO\"\n   ```",
        "code": "public class StringBufferDemo {\n    public static void main(String[] args) {\n        // Using StringBuffer for efficient modifications\n        StringBuffer sb = new StringBuffer(\"Hello\");\n        sb.append(\" World\"); // Modifies the same object\n        System.out.println(sb); // Output: Hello World\n\n        // Demonstrating String immutability\n        String str = \"Hello\";\n        String newStr = str.concat(\" World\"); // Creates a new object\n        System.out.println(newStr); // Output: Hello World\n    }\n}"
      },
      {
        "question": "6. Explain try, catch, and finally keywords in Java.",
        "answer": "In Java, the try, catch, and finally keywords are used for exception handling, enabling developers to handle runtime errors gracefully and maintain normal program flow.\n\n1. **try block:** The try block contains the code that might throw an exception. If an exception occurs, it is passed to the corresponding catch block.\n   \n2. **catch block:** The catch block is used to handle specific exceptions. You can have multiple catch blocks to handle different types of exceptions separately.\n   \n3. **finally block:** The finally block contains code that will execute regardless of whether an exception was thrown or caught. It is typically used for cleanup activities, such as closing resources.",
        "code": "public class ExceptionHandlingDemo {\n    public static void main(String[] args) {\n        try {\n            int result = 10 / 0; // This will throw an ArithmeticException\n            System.out.println(\"Result: \" + result);\n        } catch (ArithmeticException e) {\n            System.out.println(\"Exception caught: Division by zero.\");\n        } finally {\n            System.out.println(\"Finally block executed.\"); // Cleanup code\n        }\n    }\n}"
      },
      {
        "question": "7. What is a thread? Explain thread lifecycle.",
        "answer": "A thread in Java is the smallest unit of a process that runs independently. It is a lightweight subprocess and is part of a multithreaded environment, allowing multiple tasks to run concurrently within a program. Threads enhance the efficiency of CPU utilization by enabling parallel execution.\n\n**Thread Lifecycle:**\n1. **New (Created):** A thread begins its lifecycle in the 'new' state when it is created using the `Thread` class or implementing the `Runnable` interface but hasn't started executing.\n   Example: `Thread t = new Thread();`\n\n2. **Runnable:** The thread enters the runnable state after the `start()` method is called. It is ready to run and waiting for CPU scheduling.\n\n3. **Running:** When a thread scheduler selects the thread, it moves to the running state, where the `run()` method executes.\n\n4. **Blocked/Waiting:** The thread enters this state if it is waiting for some resource or signal, such as waiting for I/O operations to complete.\n\n5. **Terminated:** The thread ends its lifecycle after completing execution or when it is explicitly stopped.",
        "code": "class MyThread extends Thread {\n        public void run() {\n        System.out.println(\"Thread is running...\");\n    }\n\n    public static void main(String[] args) {\n        MyThread thread = new MyThread();\n        thread.start(); // Moves thread to Runnable state\n    }\n}"
      },
      {
        "question": "8. What is a package? Explain package creation and import in detail with an example.",
        "answer": "In Java, a package is a way of grouping related classes and interfaces together, which helps in organizing code and avoiding name conflicts. Packages also make it easier to manage access control and reuse code.\n\n**Types of Packages:**\n1. **Built-in Packages:** Java provides several built-in packages like `java.util` (for utility classes) and `java.io` (for input/output operations).\n2. **User-defined Packages:** Developers can create their own packages to organize their classes as per their needs.\n\n**Steps to Create and Import a Package:**\n\n1. **Creating a Package:**\n   - Use the `package` keyword at the beginning of the Java file to specify the package name.\n   - Save the file in a folder that matches the package name.\n\n   Example:\n   ```java\n   package mypackage;\n\n   public class MyClass {\n       public void displayMessage() {\n           System.out.println(\"Hello from MyClass in mypackage!\");\n       }\n   }\n   ```\n\n   Save this file as `MyClass.java` inside a folder named `mypackage`.\n\n2. **Compiling the Package:**\n   - Compile the file using the command: `javac -d . MyClass.java`\n   - The `-d .` option creates the package structure in the current directory.\n\n3. **Using the Package:**\n   - Import the package in another class using the `import` keyword.\n   - Call the methods or access the classes from the package.\n\n   Example:\n   ```java\n   import mypackage.MyClass;\n\n   public class TestPackage {\n       public static void main(String[] args) {\n           MyClass obj = new MyClass();\n           obj.displayMessage();\n       }\n   }\n   ```\n\n4. **Running the Program:**\n   - Compile the `TestPackage.java` file.\n   - Run the program: `java TestPackage`\n\nThe output will be: \"Hello from MyClass in mypackage!\"\n\nPackages improve code modularity and reusability and make large-scale development more manageable.",
        "code": "package mypackage;\n\npublic class MyClass {\n    public void displayMessage() {\n        System.out.println(\"Hello from MyClass in mypackage!\");\n    }\n}\n\n// File: TestPackage.java\nimport mypackage.MyClass;\n\npublic class TestPackage {\n    public static void main(String[] args) {\n        MyClass obj = new MyClass();\n        obj.displayMessage();\n    }\n}"
      },
      {
        "question": "9. What is <applet>? How can we pass parameters to an applet?",
        "answer": "In Java, `<applet>` is an HTML tag that is used to embed a Java applet in a webpage. Applets are small Java applications that run within a web browser or an applet viewer. Although applets are now considered outdated, they were widely used for interactive web applications.\n\n**Passing Parameters to an Applet:**\n1. Parameters can be passed to an applet using the `<param>` tag inside the `<applet>` tag in an HTML file.\n2. The applet can retrieve these parameters using the `getParameter(String name)` method in the Java code.\n\nThe `<param>` tag specifies the name and value of the parameter. The applet reads these values during its execution.",
        "code": "import java.applet.Applet;\nimport java.awt.Graphics;\n\npublic class ParamApplet extends Applet {\n    String message;\n\n    @Override\n    public void init() {\n        message = getParameter(\"message\"); // Retrieves the parameter value\n        if (message == null) {\n            message = \"Default Message\"; // Fallback if no parameter is passed\n        }\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawString(message, 20, 20); // Displays the message\n    }\n}\n\n// Corresponding HTML File\n// <html>\n// <body>\n// <applet code=\"ParamApplet.class\" width=\"300\" height=\"100\">\n// <param name=\"message\" value=\"Hello, Applet!\">\n// </applet>\n// </body>\n// </html>"
      },
      {
        "question": "10. What is method overloading? Differentiate between method overloading and overriding.",
        "answer": "Method overloading is a feature in Java where two or more methods in the same class share the same name but differ in their parameter lists (number, type, or order of parameters). It provides multiple ways to perform a similar task.\n\n**Difference Between Method Overloading and Method Overriding:**\n1. **Definition:**\n   - Overloading: Allows multiple methods with the same name but different parameter lists within the same class.\n   - Overriding: Redefines a method of the parent class in the child class to provide a specific implementation.\n\n2. **Parameters:**\n   - Overloading: Parameters must be different (number, type, or order).\n   - Overriding: Parameters must be the same as the parent class method.\n\n3. **Access:**\n   - Overloading: Can exist in the same or different classes (inheritance not required).\n   - Overriding: Requires inheritance, as the method is redefined in a child class.\n\n4. **Binding:**\n   - Overloading: Resolved at compile time (static binding).\n   - Overriding: Resolved at runtime (dynamic binding).",
        "code": "class OverloadingDemo {\n    // Overloaded methods\n    void display(int a) {\n        System.out.println(\"Display with an integer: \" + a);\n    }\n\n    void display(String str) {\n        System.out.println(\"Display with a string: \" + str);\n    }\n\n    public static void main(String[] args) {\n        OverloadingDemo obj = new OverloadingDemo();\n        obj.display(10);  // Calls the first method\n        obj.display(\"Hello\");  // Calls the second method\n    }\n}\n\nclass Parent {\n    void show() {\n        System.out.println(\"Parent show method\");\n    }\n}\n\nclass Child extends Parent {\n    // Override\n    void show() {\n        System.out.println(\"Child show method\");\n    }\n\n    public static void main(String[] args) {\n        Parent obj = new Child(); // Upcasting\n        obj.show(); // Calls the overridden method in Child class\n    }\n}"
      },
      {
        "question": "11. Explain bitwise operators in Java.",
        "answer": "Bitwise operators in Java perform operations on individual bits of integer types, such as int and long. They are used for low-level programming, such as working with flags or manipulating binary data. \n\n**Bitwise Operators:**\n\n1. **AND (&):** Performs a bitwise AND operation. It returns 1 if both corresponding bits are 1; otherwise, it returns 0.\n   Example: `5 & 3` (Binary: 0101 & 0011) Result: 1 (Binary: 0001).\n\n2. **OR (|):** Performs a bitwise OR operation. It returns 1 if either of the corresponding bits is 1.\n   Example: `5 | 3` (Binary: 0101 | 0011) Result: 7 (Binary: 0111).\n\n3. **XOR (^):** Performs a bitwise XOR operation. It returns 1 if the corresponding bits are different; otherwise, it returns 0.\n   Example: `5 ^ 3` (Binary: 0101 ^ 0011) Result: 6 (Binary: 0110).\n\n4. **Complement (~):** Inverts all bits of the number. Each 0 becomes 1 and each 1 becomes 0.\n   Example: `~5` (Binary: ~0101) Result: -6 (Binary for -6 in two's complement: 1010).\n\n5. **Left Shift (<<):** Shifts bits to the left and fills zeros in the vacant positions. It effectively multiplies the number by 2 for each shift.\n   Example: `5 << 1` (Binary: 0101 << 1) Result: 10 (Binary: 1010).\n\n6. **Right Shift (>>):** Shifts bits to the right and fills the leftmost positions with the sign bit (0 for positive numbers, 1 for negative numbers). It effectively divides the number by 2 for each shift.\n   Example: `5 >> 1` (Binary: 0101 >> 1) Result: 2 (Binary: 0010).\n\n7. **Unsigned Right Shift (>>>):** Shifts bits to the right and fills the leftmost positions with 0, regardless of the sign.\n   Example: `-5 >>> 1` (Binary: -5 in two's complement is 11111111 11111111 11111111 11111011; >>> 1) Result: 2147483645.",
        "code": "public class BitwiseOperatorsDemo {\n    public static void main(String[] args) {\n        int a = 5; // Binary: 0101\n        int b = 3; // Binary: 0011\n\n        // Bitwise AND\n        System.out.println(\"a & b: \" + (a & b)); // Output: 1\n\n        // Bitwise OR\n        System.out.println(\"a | b: \" + (a | b)); // Output: 7\n\n        // Bitwise XOR\n        System.out.println(\"a ^ b: \" + (a ^ b)); // Output: 6\n\n        // Bitwise Complement\n        System.out.println(\"~a: \" + (~a)); // Output: -6\n\n        // Left Shift\n        System.out.println(\"a << 1: \" + (a << 1)); // Output: 10\n\n        // Right Shift\n        System.out.println(\"a >> 1: \" + (a >> 1)); // Output: 2\n\n        // Unsigned Right Shift\n        System.out.println(\"-5 >>> 1: \" + (-5 >>> 1)); // Output: 2147483645\n    }\n}"
      },
      {
        "question": "12. What is a singly linked list? Write a program to create and display a singly linked list.",
        "answer": "A singly linked list is a linear data structure in which each element (called a node) contains two parts: data and a reference (or link) to the next node in the sequence. The last node's reference points to null, indicating the end of the list. Singly linked lists are dynamic and allow for efficient insertion and deletion operations.",
        "code": "class Node {\n    int data;\n    Node next; // Reference to the next node\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\npublic class SinglyLinkedList {\n    private Node head; // Head of the linked list\n\n    // Method to add a new node to the linked list\n    public void addNode(int data) {\n        Node newNode = new Node(data);\n\n        if (head == null) {\n            head = newNode;\n        } else {\n            Node temp = head;\n            while (temp.next != null) {\n                temp = temp.next;\n            }\n            temp.next = newNode;\n        }\n    }\n\n    // Method to display the linked list\n    public void displayList() {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data + \" -> \");\n            temp = temp.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args) {\n        SinglyLinkedList list = new SinglyLinkedList();\n\n        // Adding nodes to the linked list\n        list.addNode(10);\n        list.addNode(20);\n        list.addNode(30);\n\n        // Displaying the linked list\n        System.out.println(\"Singly Linked List:\");\n        list.displayList();\n    }\n}"
      },
      {
        "question": "13. Write a program to accept a number from the command line and raise a user-defined exception if it is a negative number.",
        "answer": "The program demonstrates how to accept a number as a command-line argument, check if it is negative, and raise a user-defined exception if it is. User-defined exceptions are created by extending the Exception class.",
        "code": "class NegativeNumberException extends Exception {\n    public NegativeNumberException(String message) {\n        super(message);\n    }\n}\n\npublic class CustomExceptionDemo {\n    public static void main(String[] args) {\n        try {\n            if (args.length == 0) {\n                throw new IllegalArgumentException(\"Please provide a number as a command-line argument.\");\n            }\n\n            int number = Integer.parseInt(args[0]);\n\n            if (number < 0) {\n                throw new NegativeNumberException(\"Negative numbers are not allowed: \" + number);\n            }\n\n            System.out.println(\"The number is: \" + number);\n        } catch (NegativeNumberException e) {\n            System.out.println(\"Exception caught: \" + e.getMessage());\n        } catch (NumberFormatException e) {\n            System.out.println(\"Invalid input. Please enter a valid integer.\");\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}"
      }
      
    ]
  },
  "wd": {
    "mcq": [
      {
        "question": "1. What does HTML stand for?",
        "options": ["a) HyperText Markup Language", "b) HyperTransfer Markup Language"],
        "correctAnswer": "a",
        "id": "wd-q1"
      }
    ],
    "onemarks": [
      {
        "question": "1. What is HTML?",
        "answer": "HTML (HyperText Markup Language) is the standard markup language used to create web pages."
      }
    ],
    "long": [
      {
        "question": "1. Explain the structure of an HTML document.",
        "answer": "An HTML document has the following structure:\n- **<!DOCTYPE html>**: Declares the document type as HTML5.\n- **<html>**: The root element of the page.\n- **<head>**: Contains metadata, such as the title and links to CSS/JavaScript.\n- **<body>**: Contains the visible content, such as text, images, and links."
      }
    ]
  },
  "net": {
    "mcq": [
      {
        "question": "1. What is CTS?",
        "options": ["a) Common Language Specification", "b) Code Translation System"],
        "correctAnswer": "a",
        "id": "net-q1"
      }
    ],
    "onemarks": [
      {
        "question": "1. What is CTS?",
        "answer": "The CLS is a common platform that integrates code and components from multiple .NET programming languages.\nIt ensures that objects written in different languages can interact seamlessly within the .NET Framework, promoting interoperability."
      },
      {
        "question": "2. What is Garbage Collection?",
        "answer": "Garbage collection is a mechanism that allows the computer to detect when an object can no longer be accessed.\nIt automatically frees up memory by deallocating objects that are no longer in use, thus preventing memory leaks and improving application performance."
      }
    ],
    "long": [
      {
        "question": "1. Explain the .NET Framework in detail.",
        "answer": "The .NET Framework is a software framework developed by Microsoft that supports the development and execution of applications across various platforms.\nIt provides a large class library called the Framework Class Library (FCL) and a runtime environment called the Common Language Runtime (CLR).\nThe CLR manages the execution of .NET programs by providing services like memory management, security, and exception handling.\nThe FCL includes a wide range of reusable classes, interfaces, and types for tasks like file handling, networking, and database access.\nThe .NET Framework supports multiple programming languages, such as C#, VB.NET, and F#, allowing developers to choose the language that best suits their needs."
      }
    ]
  },
  "practical": {
    "mcq": [
      {
        "question": "1. Which language is commonly used for practical programming in BCA?",
        "options": ["a) C#", "b) HTML"],
        "correctAnswer": "a",
        "id": "practical-q1"
      }
    ],
    "onemarks": [
      {
        "question": "1. What is a practical program?",
        "answer": "A practical program is a hands-on coding exercise that demonstrates the application of theoretical concepts in a real-world scenario."
      }
    ],
    "long": [
      {
        "question": "1. Write a program to implement a simple calculator.",
        "answer": "Here is a sample program in C# to implement a simple calculator:\n\nusing System;\n\nclass Calculator {\n    static void Main(string[] args) {\n        Console.WriteLine(\"Enter two numbers:\");\n        double num1 = Convert.ToDouble(Console.ReadLine());\n        double num2 = Convert.ToDouble(Console.ReadLine());\n        \n        Console.WriteLine(\"Select operation (+, -, *, /):\");\n        char operation = Convert.ToChar(Console.ReadLine());\n        \n        double result = 0;\n        switch (operation) {\n            case '+':\n                result = num1 + num2;\n                break;\n            case '-':\n                result = num1 - num2;\n                break;\n            case '*':\n                result = num1 * num2;\n                break;\n            case '/':\n                result = num1 / num2;\n                break;\n            default:\n                Console.WriteLine(\"Invalid operation\");\n                return;\n        }\n        Console.WriteLine($\"Result: {result}\");\n    }\n}"
      }
    ]
  }
}